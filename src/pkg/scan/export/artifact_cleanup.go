package export

import (
	"context"
	"fmt"
	"github.com/goharbor/harbor/src/common/job"
	"github.com/goharbor/harbor/src/jobservice/logger"
	"github.com/goharbor/harbor/src/lib/q"
	"github.com/goharbor/harbor/src/pkg/registry"
	"github.com/goharbor/harbor/src/pkg/task"
	"time"
)

const DefaultTimeWindowMinutes = 1440
const DefaultPageSize = 1000
const VendorType = "SCAN_DATA_EXPORT"
const DigestKey = "artifact_digest"
const CreateTimestampKey = "create_ts"
const TimeWindowKey = "time_window"
const PageSizeKey = "page_size"

// CleanupSettings provides mechanism to override defaults of the clean-up job.
type CleanupSettings struct {
	params map[string]interface{}
}

func NewCleanupSettings() *CleanupSettings {
	return &CleanupSettings{params: map[string]interface{}{}}
}

func (settings *CleanupSettings) Set(key string, value interface{}) {
	settings.params[key] = value
}

func (settings *CleanupSettings) Get(key string) interface{} {
	return settings.params[key]
}

// ArtifactCleanupManager specifies a contract for all export data cleanup logic.
type ArtifactCleanupManager interface {
	Execute(ctx context.Context) error
	Configure(settings *CleanupSettings)
}

var CleanupManager = NewCleanupManager()

func NewCleanupManager() ArtifactCleanupManager {
	return &exportOCIArtifactCleanupManager{
		execMgr:           task.ExecMgr,
		regCli:            registry.Cli,
		timeWindowMinutes: 0,
		pageSize:          0,
	}
}

func NewCleanupManagerWithOverrides(timeWindowMinutes int, pageSize int) ArtifactCleanupManager {
	return &exportOCIArtifactCleanupManager{
		execMgr:           task.ExecMgr,
		regCli:            registry.Cli,
		timeWindowMinutes: timeWindowMinutes,
		pageSize:          pageSize,
	}
}

// exportOCIArtifactCleanupManager cleans up the OCI artifacts generated by the scan data export job
type exportOCIArtifactCleanupManager struct {
	execMgr           task.ExecutionManager
	regCli            registry.Client
	timeWindowMinutes int
	pageSize          int
}

func (ec *exportOCIArtifactCleanupManager) Configure(settings *CleanupSettings) {
	if timeWindowMins := settings.Get(TimeWindowKey); timeWindowMins != nil {
		ec.timeWindowMinutes = timeWindowMins.(int)
	}
	if pageSize := settings.Get(PageSizeKey); pageSize != nil {
		ec.pageSize = pageSize.(int)
	}
}

func (ec *exportOCIArtifactCleanupManager) Execute(ctx context.Context) error {
	currentTime := time.Now()
	logger.Infof("Beginning clean-up of scan data export artifacts at TS : %v", currentTime)
	duration := time.Duration(DefaultTimeWindowMinutes) * time.Minute
	if ec.timeWindowMinutes > 0 {
		duration = time.Duration(ec.timeWindowMinutes) * time.Minute
	}
	timeRG := q.Range{
		Max: currentTime.Add(-duration).Format(time.RFC3339),
	}
	orList := q.NewOrList([]interface{}{job.JobServiceStatusCancelled, job.JobServiceStatusError, job.JobServiceStatusStopped, job.JobServiceStatusSuccess})
	lastTaskID := int64(0)

	pageSize := DefaultPageSize
	if ec.pageSize > 0 {
		pageSize = ec.pageSize
	}
	for {
		taskRG := q.Range{Min: lastTaskID}
		query := &q.Query{
			Keywords:   map[string]interface{}{"end_time": timeRG, "vendor_type": VendorType, "status": &orList, "id": &taskRG},
			Sorts:      []*q.Sort{q.NewSort("id", false)},
			PageNumber: 1,
			PageSize:   int64(pageSize),
			Sorting:    "",
		}

		execs, err := ec.execMgr.List(ctx, query)
		if err != nil {
			logger.Errorf("Encountered error when listing completed scan data export jobs: % v", err)
			return err
		}
		if len(execs) == 0 {
			break
		}

		for _, exec := range execs {
			artifactCreateTs := int64(exec.ExtraAttrs[CreateTimestampKey].(float64))
			if artifactCreateTs > currentTime.Unix() {
				continue
			}
			repositoryName := fmt.Sprintf("scandata_export_%v", exec.ID)
			digest := exec.ExtraAttrs[DigestKey].(string)
			err := ec.regCli.DeleteBlob(repositoryName, digest)
			if err != nil {
				logger.Errorf("ScanArtifactCleanup_%v - Failed to delete artifact %s:%s, create timestamp %v. Error : %v", currentTime.Unix(), repositoryName, digest, artifactCreateTs, err)
				continue
			}
		}

		lastTaskID = execs[len(execs)-1].ID
	}

	return nil
}
