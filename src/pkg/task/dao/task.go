// Copyright Project Harbor Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dao

import (
	"errors"
	"time"

	"github.com/astaxie/beego/orm"
	"github.com/goharbor/harbor/src/common/dao"
)

// TaskDao defines the interface to access the Task data model
type TaskDao interface {
	Create(task *Task) (int64, error)
	Get(id int64) (*Task, error)
	Update(task *Task, cols ...string) error
	UpdateStatus(id int64, status string, statusCode int,
		statusRevision int64, endTime time.Time) error
	Delete(id int64) error
	CreateCheckInData(data *CheckInData) (int64, error)
	UpdateCheckInData(data *CheckInData, cols ...string) error
	ListCheckInData(taskID int64) ([]*CheckInData, error)
	DeleteCheckInData(id int64) error
	GetGroupStatus(groupID int64) ([]*StatusCount, error)
	GetMaxEndTime(groupID int64) (time.Time, error)
}

// New creates a default implementation for TaskDao
func New() TaskDao {
	return &taskDao{}
}

type taskDao struct{}

func (t *taskDao) Create(task *Task) (int64, error) {
	return dao.GetOrmer().Insert(task)
}
func (t *taskDao) Get(id int64) (*Task, error) {
	task := &Task{
		ID: id,
	}
	if err := dao.GetOrmer().Read(task); err != nil {
		if err == orm.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return task, nil
}
func (t *taskDao) Update(task *Task, cols ...string) error {
	_, err := dao.GetOrmer().Update(task, cols...)
	return err
}
func (t *taskDao) UpdateStatus(id int64, status string, statusCode int,
	statusRevision int64, endTime time.Time) error {
	// use raw sql rather than the ORM as the sql generated by ORM isn't a "single" statement
	// which means the operation isn't atomic
	sql := `update task set status = ?, status_code = ?, status_revision = ?, end_time = ? 
		where id = ? and (status_revision = ? and status_code < ? or status_revision < ?) `
	_, err := dao.GetOrmer().Raw(sql, status, statusCode, statusRevision, endTime, id,
		statusRevision, statusCode, statusRevision).Exec()
	return err
}
func (t *taskDao) Delete(id int64) error {
	_, err := dao.GetOrmer().Delete(&Task{
		ID: id,
	})
	return err
}

func (t *taskDao) CreateCheckInData(data *CheckInData) (int64, error) {
	return dao.GetOrmer().Insert(data)
}
func (t *taskDao) UpdateCheckInData(data *CheckInData, cols ...string) error {
	_, err := dao.GetOrmer().Update(data, cols...)
	return err
}
func (t *taskDao) ListCheckInData(taskID int64) ([]*CheckInData, error) {
	results := []*CheckInData{}
	_, err := dao.GetOrmer().QueryTable(&CheckInData{}).Filter("TaskID", taskID).All(&results)
	if err != nil {
		return nil, err
	}
	return results, nil
}
func (t *taskDao) DeleteCheckInData(id int64) error {
	_, err := dao.GetOrmer().Delete(&CheckInData{
		ID: id,
	})
	return err
}

func (t *taskDao) GetGroupStatus(groupID int64) ([]*StatusCount, error) {
	if groupID == 0 {
		return nil, errors.New("group ID is required")
	}
	scs := []*StatusCount{}
	_, err := dao.GetOrmer().Raw("select status, count(*) as count from task where group_id = ? group by status", groupID).QueryRows(&scs)
	if err != nil {
		return nil, err
	}
	return scs, nil
}

func (t *taskDao) GetMaxEndTime(groupID int64) (time.Time, error) {
	tm := time.Time{}
	if groupID == 0 {
		return tm, errors.New("group ID is required")
	}
	if err := dao.GetOrmer().Raw("select max(end_time) from task where group_id = ?", groupID).
		QueryRow(&tm); err != nil {
		return time.Time{}, err
	}
	return tm, nil
}
